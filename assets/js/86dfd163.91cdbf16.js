"use strict";(globalThis.webpackChunkbook_site=globalThis.webpackChunkbook_site||[]).push([[247],{707(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"chapter-5","title":"Chapter 5: User Authentication and Personalization","description":"Our RAG chatbot is architecturally sound, but it\'s impersonal. Every user gets the same experience. To create a truly engaging application, we need to know who our users are. This chapter will cover how to add user authentication to our FastAPI backend and how to use that identity to create a personalized user experience.","source":"@site/docs/chapter-5.md","sourceDirName":".","slug":"/chapter-5","permalink":"/ai-specbook/docs/chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/AnsharaAmir/ai-specbook/tree/main/docs/chapter-5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Building the RAG Chatbot","permalink":"/ai-specbook/docs/chapter-4"},"next":{"title":"Chapter 6: Urdu Translation and Multilingual Content","permalink":"/ai-specbook/docs/chapter-6"}}');var i=n(4848),o=n(8453);const a={sidebar_position:5},s="Chapter 5: User Authentication and Personalization",l={},c=[{value:"Effortless Authentication with Better-Auth",id:"effortless-authentication-with-better-auth",level:2},{value:"Integrating Better-Auth",id:"integrating-better-auth",level:3},{value:"User Profiling and Content Personalization",id:"user-profiling-and-content-personalization",level:2},{value:"Enhancing the RAG Prompt",id:"enhancing-the-rag-prompt",level:3},{value:"What&#39;s Next?",id:"whats-next",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"chapter-5-user-authentication-and-personalization",children:"Chapter 5: User Authentication and Personalization"})}),"\n",(0,i.jsx)(t.p,{children:"Our RAG chatbot is architecturally sound, but it's impersonal. Every user gets the same experience. To create a truly engaging application, we need to know who our users are. This chapter will cover how to add user authentication to our FastAPI backend and how to use that identity to create a personalized user experience."}),"\n",(0,i.jsx)(t.h2,{id:"effortless-authentication-with-better-auth",children:"Effortless Authentication with Better-Auth"}),"\n",(0,i.jsxs)(t.p,{children:["Authentication can be complex to set up. To keep things simple and secure, we'll use a fictional library called ",(0,i.jsx)(t.strong,{children:"Better-Auth"}),". Imagine ",(0,i.jsx)(t.code,{children:"Better-Auth"})," as a modern authentication handler for FastAPI that makes it trivial to add sign-up and sign-in flows, including support for social logins (like Google) and passwordless email links."]}),"\n",(0,i.jsxs)(t.p,{children:["The core idea behind ",(0,i.jsx)(t.code,{children:"Better-Auth"})," is to abstract away the complexities of OAuth2 and token management. You configure it once, and it provides you with protected routes and easy access to the current user's identity."]}),"\n",(0,i.jsx)(t.h3,{id:"integrating-better-auth",children:"Integrating Better-Auth"}),"\n",(0,i.jsxs)(t.p,{children:["Let's see how we would integrate ",(0,i.jsx)(t.code,{children:"Better-Auth"})," into our FastAPI application."]}),"\n",(0,i.jsx)(t.p,{children:"First, we would initialize it with a secret key and configure a provider, like Google."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# main.py (Updated)\nfrom fastapi import FastAPI, Depends\nfrom pydantic import BaseModel\nfrom my_rag_logic import get_rag_answer\nfrom better_auth import BetterAuth, User\n\n# 1. Initialize BetterAuth\nauth_handler = BetterAuth(\n    secret_key="YOUR_SUPER_SECRET_KEY",\n    google_oauth_client_id="YOUR_GOOGLE_CLIENT_ID",\n    google_oauth_client_secret="YOUR_GOOGLE_CLIENT_SECRET",\n)\n\napp = FastAPI()\n\n# 2. Add auth routes to the app\napp.include_router(auth_handler.router)\n\nclass Query(BaseModel):\n    question: str\n    conversation_id: str | None = None\n\n# 3. Protect the chat endpoint\n@app.post("/chat")\nasync def chat(query: Query, user: User = Depends(auth_handler.get_current_user)):\n    """\n    Receives a question, retrieves context, and returns a personalized answer.\n    The user object is now available thanks to BetterAuth.\n    """\n    answer, new_conversation_id = await get_rag_answer(\n        question=query.question,\n        conversation_id=query.conversation_id,\n        user_profile=user.profile, # Pass the user\'s profile to the logic\n    )\n    return {"answer": answer, "conversation_id": new_conversation_id}\n\n'})}),"\n",(0,i.jsxs)(t.p,{children:["With just a few lines of code, ",(0,i.jsx)(t.code,{children:"Better-Auth"})," does the following for us:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Creates API endpoints like ",(0,i.jsx)(t.code,{children:"/login/google"})," and ",(0,i.jsx)(t.code,{children:"/auth/callback"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"Handles the OAuth2 flow, exchanging a code for a user token."}),"\n",(0,i.jsxs)(t.li,{children:["Provides a ",(0,i.jsx)(t.code,{children:"Depends(auth_handler.get_current_user)"})," dependency that ensures only authenticated users can access the ",(0,i.jsx)(t.code,{children:"/chat"})," endpoint."]}),"\n",(0,i.jsxs)(t.li,{children:["Gives us a ",(0,i.jsx)(t.code,{children:"user"})," object containing their ID, email, name, and a profile we can customize."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"user-profiling-and-content-personalization",children:"User Profiling and Content Personalization"}),"\n",(0,i.jsx)(t.p,{children:"Now that we can identify users, we can start building a profile for them to personalize their experience. A user profile is a collection of information we store about a user that helps us tailor the application to their needs."}),"\n",(0,i.jsx)(t.p,{children:"This profile can be stored in our Neon Postgres database and could include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Explicit Preferences:"}),' Settings the user configures, like preferred language or chatbot personality (e.g., "formal," "witty").']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Implicit History:"})," Past conversations, topics they frequently ask about, or documents they have accessed."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"enhancing-the-rag-prompt",children:"Enhancing the RAG Prompt"}),"\n",(0,i.jsxs)(t.p,{children:["The most powerful way to use this profile is by incorporating it into our RAG prompt. By giving the ",(0,i.jsx)(t.code,{children:"GeminiModel"})," context about the user, we can get a much more personalized response."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's update our RAG logic to use the ",(0,i.jsx)(t.code,{children:"user_profile"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# my_rag_logic.py (Updated)\n\nasync def get_rag_answer(question: str, conversation_id: str | None, user_profile: dict):\n    # ... (retrieve context chunks from Qdrant as before) ...\n    context = "\\n".join(chunk.text for chunk in retrieved_chunks)\n\n    # Get user\'s name from their profile, with a default\n    user_name = user_profile.get("name", "there")\n    \n    # Get preferred tone, with a default\n    bot_personality = user_profile.get("preferred_tone", "a helpful assistant")\n\n    prompt = f"""\nYou are {bot_personality}. The user\'s name is {user_name}.\nA user has asked a question. Using ONLY the following text, please answer the user\'s question.\nAddress the user by their name in your response.\n\n---\nTEXT:\n{context}\n---\n\nQUESTION:\n{question}\n"""\n    \n    # ... (call GeminiModel and store conversation history as before) ...\n    \n    answer = gemini_model.call(prompt=prompt)\n    \n    # You could also update the user profile here, e.g., by saving the topic.\n    # db.update_user_profile(user_profile.id, {"last_topic": "some_topic"})\n\n    return answer, new_conversation_id\n'})}),"\n",(0,i.jsx)(t.p,{children:'By making this small change, our chatbot is transformed. Instead of a generic "You," it can now say, "Hi Alex, I found this information for you..." This simple act of personalization dramatically improves the user experience, making the application feel more like a personal assistant.'}),"\n",(0,i.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsx)(t.p,{children:"We've added a crucial layer to our application, enabling us to build a relationship with our users. With authentication and personalization in place, we're ready to start thinking about the user interface."}),"\n",(0,i.jsx)(t.p,{children:"In the next chapter, we'll shift our focus from the backend to the frontend. We'll explore how to build a responsive and intuitive web interface for our chatbot using a modern JavaScript framework, allowing users to interact with the powerful system we've just built."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>s});var r=n(6540);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);