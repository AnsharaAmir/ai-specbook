"use strict";(globalThis.webpackChunkbook_site=globalThis.webpackChunkbook_site||[]).push([[997],{7237(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter-3","title":"Chapter 3: Writing Your First Spec with Spec-Kit Plus","description":"In Chapter 1, we introduced the idea of \\"Spec-Driven Development\\"\u2014creating a blueprint for our software before we build it. Now, it\'s time to learn how to draw that blueprint. In this chapter, we\'ll dive into the \\"spec-first\\" methodology and use a tool called Spec-Kit Plus to write our very first specification.","source":"@site/docs/chapter-3.md","sourceDirName":".","slug":"/chapter-3","permalink":"/ai-specbook/docs/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/AnsharaAmir/ai-specbook/tree/main/docs/chapter-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Docusaurus Setup & Markdown Basics","permalink":"/ai-specbook/docs/chapter-2"},"next":{"title":"Chapter 4: Building the RAG Chatbot","permalink":"/ai-specbook/docs/chapter-4"}}');var r=n(4848),s=n(8453);const o={sidebar_position:3},a="Chapter 3: Writing Your First Spec with Spec-Kit Plus",l={},c=[{value:"The Spec-First Methodology",id:"the-spec-first-methodology",level:2},{value:"Introducing Spec-Kit Plus",id:"introducing-spec-kit-plus",level:2},{value:"Our First Spec: A <code>GeminiModel</code> Client",id:"our-first-spec-a-geminimodel-client",level:2},{value:"Breaking Down the Spec",id:"breaking-down-the-spec",level:3},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"chapter-3-writing-your-first-spec-with-spec-kit-plus",children:"Chapter 3: Writing Your First Spec with Spec-Kit Plus"})}),"\n",(0,r.jsxs)(t.p,{children:['In Chapter 1, we introduced the idea of "Spec-Driven Development"\u2014creating a blueprint for our software before we build it. Now, it\'s time to learn how to draw that blueprint. In this chapter, we\'ll dive into the "spec-first" methodology and use a tool called ',(0,r.jsx)(t.strong,{children:"Spec-Kit Plus"})," to write our very first specification."]}),"\n",(0,r.jsx)(t.h2,{id:"the-spec-first-methodology",children:"The Spec-First Methodology"}),"\n",(0,r.jsxs)(t.p,{children:["The spec-first methodology is simple but powerful: ",(0,r.jsx)(t.strong,{children:"write the spec, then write the code."})]}),"\n",(0,r.jsx)(t.p,{children:"Think back to our house analogy. You wouldn't want your plumber and your electrician showing up and just guessing where the pipes and wires should go. You'd want them to follow the blueprint."}),"\n",(0,r.jsx)(t.p,{children:"In software, the spec is our blueprint. It defines:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"What"})," our software should do."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"How"})," its different parts should interact."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"What"})," data it should expect and what data it should return."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"By writing the spec first, we catch design problems early, ensure everyone is on the same page, and create a clear guide for our implementation."}),"\n",(0,r.jsx)(t.h2,{id:"introducing-spec-kit-plus",children:"Introducing Spec-Kit Plus"}),"\n",(0,r.jsxs)(t.p,{children:["Spec-Kit Plus is a simple yet effective way to write specs. It's not a complex piece of software; it's a convention that combines two languages you already know: ",(0,r.jsx)(t.strong,{children:"Markdown"})," and ",(0,r.jsx)(t.strong,{children:"YAML"}),"."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Markdown:"})," For the human-readable, narrative part of the spec. This is where you explain the ",(0,r.jsx)(t.em,{children:"why"})," and the ",(0,r.jsx)(t.em,{children:"what"})," in plain English."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"YAML:"})," For the structured, machine-readable part of the spec. This is where you define the precise details, like function names, parameters, and data types."]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"our-first-spec-a-geminimodel-client",children:["Our First Spec: A ",(0,r.jsx)(t.code,{children:"GeminiModel"})," Client"]}),"\n",(0,r.jsxs)(t.p,{children:["Let's create a spec for a Python class that will be the heart of our AI application: a client for the Gemini language model. We'll call it ",(0,r.jsx)(t.code,{children:"GeminiModel"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the full spec. Don't worry, we'll break it down piece by piece."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-markdown",children:"# Spec: GeminiModel Client\n\n## 1. Overview\n\nThis document specifies the functionality for the `GeminiModel` class, a Python client designed to interact with the Google Gemini API. This class will handle single and parallel API calls, manage configurations, and include error handling with retries.\n\n## 2. Class Definition\n\n```yaml\nclass: GeminiModel\ndescription: A Python class for interacting with the Google Gemini large language model.\n```\n\n## 3. Methods\n\n### 3.1. `__init__` (Constructor)\n\n**Description:** Initializes the `GeminiModel` instance. It sets up the model name, configuration, and other parameters for API calls.\n\n```yaml\nmethod: __init__\ndescription: Constructor for the GeminiModel class.\nparameters:\n  - name: model_name\n    type: str\n    required: false\n    default: \"gemini-1.5-flash\"\n    description: The name of the Gemini model to use.\n  - name: temperature\n    type: float\n    required: false\n    default: 0.01\n    description: The sampling temperature for the model's output (controls randomness).\n  - name: finetuned_model\n    type: bool\n    required: false\n    default: false\n    description: Flag to indicate if the model is a fine-tuned version.\n  - name: distribute_requests\n    type: bool\n    required: false\n    default: false\n    description: Flag to distribute requests across different regions for better availability.\n```\n\n### 3.2. `call`\n\n**Description:** Makes a single, synchronous call to the Gemini API with a given prompt. Includes automatic retry logic.\n\n```yaml\nmethod: call\ndescription: Makes a single call to the Gemini model.\nparameters:\n  - name: prompt\n    type: str\n    required: true\n    description: The text prompt to send to the model.\n  - name: parser_func\n    type: callable\n    required: false\n    description: An optional function to parse the model's raw text output.\nreturns:\n  - name: response\n    type: str\n    description: The processed text response from the model.\n```\n\n### 3.3. `call_parallel`\n\n**Description:** Makes multiple calls to the Gemini API in parallel using a thread pool for efficiency.\n\n```yaml\nmethod: call_parallel\ndescription: Makes multiple parallel calls to the Gemini model.\nparameters:\n  - name: prompts\n    type: List[str]\n    required: true\n    description: A list of text prompts to send to the model.\n  - name: timeout\n    type: int\n    required: false\n    default: 60\n    description: The timeout in seconds for each parallel request.\nreturns:\n  - name: responses\n    type: List[Optional[str]]\n    description: A list of text responses, with `None` for any failed requests.\n```\n"})}),"\n",(0,r.jsx)(t.h3,{id:"breaking-down-the-spec",children:"Breaking Down the Spec"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"The Narrative (Markdown):"})," The headings (",(0,r.jsx)(t.code,{children:"## 1. Overview"}),") and the ",(0,r.jsx)(t.strong,{children:"Description"})," fields are written in Markdown. They provide context and explain the purpose of each part of the class in simple terms."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"The Structure (YAML):"})," The ",(0,r.jsx)(t.code,{children:"class"}),", ",(0,r.jsx)(t.code,{children:"method"}),", ",(0,r.jsx)(t.code,{children:"parameters"}),", and ",(0,r.jsx)(t.code,{children:"returns"}),' sections are written in YAML, inside Markdown code blocks. This gives us a structured, easy-to-read definition of our code\'s "shape."']}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["This spec is now our ",(0,r.jsx)(t.strong,{children:"single source of truth"}),". When we write our Python code, we will follow this blueprint exactly. If we decide to change how the ",(0,r.jsx)(t.code,{children:"GeminiModel"})," works, we'll update the spec ",(0,r.jsx)(t.em,{children:"first"}),"."]})}),"\n",(0,r.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsx)(t.p,{children:"Congratulations on writing your first spec! You've taken a huge step towards building more robust and maintainable software."}),"\n",(0,r.jsxs)(t.p,{children:["In the next chapter, we'll take this spec and use it to write the actual Python code for our ",(0,r.jsx)(t.code,{children:"GeminiModel"})," class. We'll see how having a clear spec makes the coding process faster, easier, and more enjoyable."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,t,n){n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);